# 4.2 Sorting and Searching

## Introduction
The sorting problem involves rearranging an array of items into **ascending order**. This section explores two classical algorithms — **binary search** and **mergesort** — and their significant applications where efficiency is critical.

---

## Twenty Questions and Binary Search

### Binary Search
In the game *Twenty Questions*, the task is to guess a secret number between `0` and `n − 1`. Assuming `n` is a power of 2, the most effective strategy is to maintain an interval containing the secret number, guess the middle value, and use the response to halve the interval. This approach is implemented in `Questions.java` and represents a general **binary search** technique.

### Analysis of Running Time
Each iteration reduces the interval size by a factor of 2 until the base case `n = 1` is reached. Thus, the running time of binary search is **lg n**.

### Linear–Logarithm Chasm
An alternative is a brute-force search, guessing 0, 1, 2, etc., until the correct number is found. This has a worst-case running time of **n**, showing a vast difference between **n** and **lg n** — known as the **linear–logarithm chasm**.

### Binary Representation
Binary search closely resembles converting a number to binary. Each question determines one bit of the answer. For example, for the number 77, the sequence “no yes yes no no yes no” gives the binary representation `1001101`.

---

## Bisection Search

### Concept
Given an increasing function `f(x)`, the task is to find `x` such that `f(x) = y`. Starting with an interval `(lo, hi)` known to contain `x`, the recursive strategy is:

1. Compute `mid = lo + (hi − lo) / 2`
2. **Base case:** If `(hi − lo)` < δ, return `mid` as an estimate.
3. **Recursive step:** If `f(mid) > y`, search in `(lo, mid)`; otherwise, in `(mid, hi)`.

This strategy, used in the `inverseCDF()` method in `Gaussian.java`, is known as **bisection search**.

---

## Binary Search in a Sorted Array

Binary search is often used to find an item in a sorted array. Examine the middle element; if it matches the target, return it. Otherwise, eliminate either the lower or upper subarray and repeat. This algorithm is implemented in `BinarySearch.java`.

---

## Insertion Sort

### Algorithm
Insertion sort is a brute-force algorithm that works similarly to sorting playing cards. For each element, it finds the correct position among the already sorted ones.

```java
public static void sort(String[] a) {
    int n = a.length;
    for (int i = 1; i < n; i++) {
        for (int j = i; j > 0; j--) {
            if (a[j-1].compareTo(a[j]) > 0)
                exch(a, j, j-1);
            else break;
        }
    }
}
```

At each iteration, the first *i* elements are sorted. The inner loop moves `a[i]` into its proper position by comparing and exchanging values.

### Analysis of Running Time
Although insertion sort has nested loops, the **break** statement prevents uniform iteration counts.

- **Best case:** Already sorted array → linear running time (~n)
- **Worst case:** Reverse sorted array → quadratic running time (~½ n²)
- **Average case:** Random input → quadratic running time (~¼ n²)

### Sorting Other Data Types
Java provides the **Comparable** interface, allowing insertion sort to work with different object types. `Insertion.java` implements this generalized version.

### Empirical Analysis
`InsertionTest.java` empirically verifies that insertion sort behaves quadratically for random inputs.

---

## Mergesort

### Algorithm
To design a faster algorithm, we use the **divide-and-conquer** approach. The idea is to divide the array into two halves, sort each half, and then merge them.

Steps for mergesort on `a[lo, hi)`:

1. **Base case:** If the subarray length is 0 or 1, it is already sorted.
2. **Reduction step:** Compute `mid = lo + (hi − lo) / 2`.
   - Recursively sort `a[lo, mid)` and `a[mid, hi)`.
   - Merge the results.

`Merge.java` implements this algorithm, and a trace of the merging process helps visualize the recursive pattern.

### Analysis of Running Time
In the worst case, mergesort performs between **½ n lg n** and **n lg n** comparisons. Its running time is **linearithmic**, a major improvement over quadratic sorts.

### Quadratic–Linearithmic Chasm
The difference between **n²** and **n lg n** is significant for practical applications — mergesort scales far better as input sizes grow.

### Divide-and-Conquer Algorithms
This technique applies broadly to many computational problems, forming a key principle of algorithm design.

---

## Reduction to Sorting
A problem A is said to **reduce** to another problem B if solving B helps solve A.  
Example: To check if all elements in an array are distinct, sort the array and make a single pass to check if any consecutive elements are equal.

---

## Frequency Counts and Zipf’s Law

### Frequency Counting
`FrequencyCount.java` reads a sequence of strings and outputs distinct values with their counts in decreasing order. It uses two sorts:

1. **Sorting Strings:** Brings identical strings together for counting.
2. **Sorting Counters:** Orders results by frequency.

Example:
```
Input:  to be or not to be to
Sorted: be be not or to to to
```
Equal strings are adjacent, simplifying counting.

### Zipf’s Law
An observed linguistic phenomenon, **Zipf’s Law**, states that in a text with *m* distinct words, the frequency of the *i-th* most frequent word is approximately proportional to **1/i**.

---

## Summary
Sorting and searching are core algorithmic problems that highlight the importance of efficiency.  
- **Binary search** reduces problem size logarithmically.  
- **Insertion sort** provides a simple but slower quadratic method.  
- **Mergesort** demonstrates divide-and-conquer power with linearithmic growth.  
Understanding these algorithms builds the foundation for analyzing and improving performance in more complex systems.
