# 4.4 Symbol Tables

## Introduction
A **symbol table** is a data type that associates **values with keys**. It enables clients to store key–value pairs and retrieve values based on a specified key. Symbol tables are foundational to many algorithms and applications, including compilers, databases, and search engines.

---

## Symbol Table API

A symbol table is a collection of key–value pairs, parameterized with generic types `Key` and `Value`. The basic operations include:

- `put(Key key, Value value)` — insert or update a key–value pair.
- `get(Key key)` — retrieve the value associated with a key.
- `delete(Key key)` — remove a key and its value.
- `contains(Key key)` — check whether the table contains a key.
- `isEmpty()` — test whether the table is empty.
- `size()` — return the number of key–value pairs.
- `keys()` — iterate over all keys in the table.

### Design Conventions

1. **Immutable Keys:** Keys do not change while in the symbol table.
2. **Replace-the-Old-Value Policy:** Inserting a key that already exists replaces its value.
3. **Not Found:** `get()` returns `null` if the key is not found.
4. **No Null Keys or Values:** Nulls are disallowed to ensure consistency and enable this implementation of `contains()`:

```java
public boolean contains(Key key) {
    return get(key) != null;
}
```

### Iteration
The `keys()` method allows iteration over all key–value pairs, for example:

```java
ST<String, Integer> st = new ST<String, Integer>();
for (String key : st.keys())
    StdOut.println(key + " " + st.get(key));
```

### Hashable and Comparable Keys
- **Hashable Keys:** Classes in Java inherit `equals()` and `hashCode()`, enabling hashing.
- **Comparable Keys:** Many key types (e.g., `String`, `Integer`) implement `Comparable`, allowing ordered operations.

---

## Symbol Table Clients

### 1. Dictionary Lookup
The simplest client builds a symbol table by calling `put()` for successive key–value pairs and later retrieving values using `get()`.

`Lookup.java` builds a symbol table from a CSV file and supports lookups via standard input.

### 2. Indexing
`Index.java` uses both `get()` and `put()` to build an index mapping words to the positions where they occur in a text, outputting a sorted list of results.

---

## Elementary Implementations

### Sequential Search
The simplest symbol-table implementation stores key–value pairs in an **unordered linked list** or array. Searching requires examining each element sequentially until the key is found.

`SequentialSearchST.java` implements this approach.

- **Advantages:** Simple to implement.
- **Disadvantages:** Linear-time search (`O(n)`) makes it impractical for large datasets.

### Binary Search
Alternatively, use two **parallel sorted arrays** — one for keys, one for values — and apply **binary search** for lookups.

`BinarySearchST.java` implements this method.

- **Advantages:** Fast search (`O(log n)`).
- **Disadvantages:** Insertion is slow (`O(n)`) due to shifting elements.

---

## Hash Tables

### Concept
A **hash table** uses a **hash function** to distribute keys uniformly across `m` linked lists (buckets). Each list stores all key–value pairs whose keys hash to the same index.

### Representation
The table maintains an array of `m` linked lists. Each list contains all keys with hash value `i`.

### Hash Function
Every Java class provides `hashCode()`. The hash value is computed as:

```java
private int hash(Key key) {
    return Math.abs(key.hashCode() % m);
}
```

This maps a key to an index between `0` and `m−1`.

### Operations

- **Search:** Compute the hash value → locate the linked list → sequentially search within it.
- **Insert:** Compute hash value → if key exists, replace its value; otherwise, add a new node at the list’s front.

`HashST.java` implements this design with a dynamically resizing array, keeping the average number of keys per list between 1 and 8.

### Performance
If the hash function distributes keys uniformly, **put()** and **get()** operations run in **amortized constant time**.

---

## Binary Search Trees (BSTs)

### Definition
A **binary tree** is a recursive structure:
- Each node contains a key–value pair.
- Left subtree keys are smaller.
- Right subtree keys are larger.

Nodes with null links are **leaves**, and the **height** of the tree is the number of links on the longest path from the root to a leaf.

### Representation
Each node is defined as:

```java
private class Node {
    private Key key;
    private Value val;
    private Node left, right;
}
```

### Operations

#### Search
1. If tree is empty → return null.
2. If key equals node’s key → return value.
3. If key < node’s key → search left subtree.
4. If key > node’s key → search right subtree.

#### Insert
1. If tree is empty → create a new node.
2. If key < node’s key → insert into left subtree.
3. If key > node’s key → insert into right subtree.
4. If key already exists → update its value.

### Performance Characteristics
- **Best case:** Perfectly balanced → `O(log n)` for both put and get.
- **Average case:** Random keys → `~2 ln n` comparisons.
- **Worst case:** Keys inserted in order → linear time `O(n)` (tree degenerates to a linked list).

### Balanced BSTs: Red–Black Trees
**Red–black trees** eliminate the worst-case behavior of BSTs by maintaining balance, ensuring logarithmic performance for all operations.

---

## Traversing a BST

To process all nodes in sorted order, use **inorder traversal**:

```java
private void traverse(Node x) {
    if (x == null) return;
    traverse(x.left);
    StdOut.println(x.key);
    traverse(x.right);
}
```

This forms the basis of the `keys()` method in `BST.java`.

---

## Ordered Symbol Table Operations

Because BSTs maintain key order, they support additional operations:

- **Minimum / Maximum:** Follow left (or right) links until `null`.
- **Size:** Keep a counter `n` for the number of nodes.
- **Range Search / Count:** Recursively return or count keys between two values.
- **Order Statistics / Ranks:** Compute the rank (position) of a key or return the *k*-th smallest key in time proportional to tree height.

`ST.java` implements these using Java’s `TreeMap`, a red–black tree-based symbol table.

---

## Set Data Type

A **set** is a simplified symbol table that stores only keys (no values).  
Its API supports the same operations minus value retrieval.

`SET.java` implements an ordered set of comparable keys.  
`DeDup.java` uses it to remove duplicate strings from input.

---

## Summary

Symbol tables provide a fundamental abstraction for associating data efficiently.  
- **Sequential search** and **binary search** form the foundation.  
- **Hash tables** deliver near-constant-time access for unordered keys.  
- **Binary search trees** and **red–black trees** support ordered operations efficiently.  
These data structures underpin modern indexing, search, and associative data storage systems.
