# 4.3 Stacks and Queues

## Introduction
In this section, we introduce two closely related data types used for manipulating large collections of objects — the **stack** and the **queue**. Both are specialized forms of collections characterized by four operations: create, insert, remove, and test for emptiness.

---

## Stacks

### Concept
A **stack** follows the **Last-In-First-Out (LIFO)** policy. The operations are traditionally named:
- `push()` — insert an item.
- `pop()` — remove an item.
- `isEmpty()` — check whether the stack is empty.

### Array Implementations of Stacks
A stack can naturally be represented using an array.  
We maintain:
- An integer `n` that stores the number of items.
- An array `items[]` containing the items, with the most recent item at `items[n-1]`.

This allows adding and removing items efficiently at the end of the array.

#### Fixed-Length Array Implementation
`ArrayStackOfStrings.java` implements a stack of strings with a fixed maximum capacity.  
- **Insert (push):** Assign `a[n]` to the new item and increment `n`.
- **Remove (pop):** Decrement `n` and return `a[n]`.

#### Resizing Array Implementation
`ResizingArrayStackOfStrings.java` improves the fixed-length approach by dynamically resizing the array:
- When the array is full, it doubles its size.
- When it is one-quarter full, it halves its size.

This **doubling-and-halving strategy** ensures that the stack neither overflows nor wastes memory.

#### Generic Stack Implementation
`ResizingArrayStack.java` extends this idea by implementing a **generic** stack using Java generics. A cast is required when creating arrays of generic types.

---

## Linked Lists

### Definition
A **singly linked list** consists of nodes where each node stores data and a reference to the next node. The last node’s reference is `null`.

Example Node definition:
```java
class Node { 
   String item; 
   Node next; 
}
```

Each `Node` object contains a data item and a reference (or link) to the next node, forming a recursive structure.

### Linking a List
To build a linked list containing `"to"`, `"be"`, `"or"`, create a `Node` for each and link them in sequence.

### Insertion at the Beginning
To insert `"not"` at the beginning:
1. Save `first` in a temporary variable `oldFirst`.
2. Create a new `Node` and assign it to `first`.
3. Set `first.item = "not"` and `first.next = oldFirst`.

### Removal from the Beginning
To remove the first node, simply set:
```java
first = first.next;
```

### Traversal
To process each item in the list:
```java
for (Node x = first; x != null; x = x.next) 
    StdOut.println(x.item);
```
This is called **traversing** the linked list.

---

## Implementing Stacks with Linked Lists

### Concept
A **linked-list-based stack** maintains a reference `first` to the most recently inserted item. This allows constant-time insertions and deletions at the beginning of the list.

`LinkedStackOfStrings.java` implements this using a private nested `Node` class, encapsulating details from the client.  
`Stack.java` extends this approach to a **generic** linked stack.

---

## Queues

### Concept
A **queue** follows the **First-In-First-Out (FIFO)** policy.  
Operations include:
- `enqueue()` — insert an item at the end.
- `dequeue()` — remove an item from the front.

### Linked-List Implementation
`Queue.java` implements a queue of strings using a linked list.  
It maintains two references:
- `first` — least recently added node.
- `last` — most recently added node.

This allows efficient insertions and deletions from opposite ends.

### Resizing Array Implementation
`ResizingArrayQueue.java` provides a queue using a resizing array. It functions similarly to the stack implementation but is more complex since insertion and removal occur at opposite ends.

---

## Generics in Collections

### Implementing Generic Collections
Generics allow building collections that can handle objects of any type specified by client code. Example:
```java
Stack<Integer> stack = new Stack<Integer>();
```

### Autoboxing and Unboxing
Java’s **autoboxing** automatically converts between primitive types and their wrapper classes (e.g., `int` ↔ `Integer`), allowing code like:
```java
stack.push(17);   // autoboxing (int -> Integer)
int a = stack.pop(); // unboxing (Integer -> int)
```

---

## Iteration

Sometimes clients need to access elements one by one without deleting them.  
Java’s **foreach** loop supports this pattern, using the `Iterable` and `Iterator` interfaces.

Example:
```java
Stack<String> stack = new Stack<String>();
...
for (String s : stack)
    StdOut.println(s);
```

Implementing this requires the class to implement `java.util.Iterator` and `java.lang.Iterable`.

---

## Applications of Stacks and Queues

### 1. Arithmetic Expression Evaluation
Stacks are essential for **parsing** and evaluating expressions.  
`Evaluate.java` demonstrates this with a fully parenthesized infix expression such as:
```
( 2 + ( ( 3 + 4 ) * ( 5 * 6 ) ) )
```
This evaluates to **212** using stacks for operators and operands.

### 2. Function Call Abstraction
Most programming languages use stacks implicitly for **function calls**.  
- **Push** the current function state (variables + next instruction).  
- **Pop** when returning to restore state and continue execution.

### 3. M/M/1 Queue Model
An important model of real-world queueing behavior characterized by:
- One server (FIFO queue).
- Exponential interarrival times with rate λ.
- Exponential service times with rate μ.

`MM1Queue.java` simulates this model and generates a histogram of waiting times.

### 4. Load Balancing
`LoadBalance.java` simulates distributing `n` items across `m` servers.  
For each item, it selects `s` random servers and assigns the item to the one with the fewest current jobs — modeling load balancing strategies.

---

## Summary
Stacks and queues are fundamental data structures used to manage dynamic collections of data efficiently.

- **Stacks**: LIFO — simple, supports undo and expression parsing.  
- **Queues**: FIFO — ideal for scheduling and simulation.  
- Both can be implemented using **arrays** or **linked lists**, and extended through **generics** for reusability.

Together, they provide a foundation for advanced data structures and algorithms in computer science.
