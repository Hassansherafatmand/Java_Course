# Chapter 2 â€“ Static Methods, Libraries, and Recursion

_Computer Science: An Interdisciplinary Approach_  
by **Robert Sedgewick & Kevin Wayne**

---

## 2.1 Static Methods

### ðŸ”¹ Overview

A **static method** in Java is the construct used to implement functions. These methods belong to the class rather than instances of the class.

Example:  
`Math.abs(a - b)` behaves as if the code were replaced with the return value from `Math.abs()` when passed the expression `a - b`.

---

### ðŸ”¹ Flow of Control

- Example: `Harmonic.java` contains two static methods:
  - `harmonic()` â†’ computes harmonic numbers
  - `main()` â†’ interacts with the user
- **Function-call trace:** helps follow the flow of control by imagining each function prints its name and arguments when called, and its return value upon returning.

---

### ðŸ”¹ Anatomy of a Static Method

A static method definition consists of:

- **Signature:** specifies name, parameters, and return type.
- **Body:** enclosed in `{}`, contains statements, local variables, and may include `return` statements.

Example:

```java
public static double average(double a, double b) {
    double sum = a + b;
    return sum / 2.0;
}
```

---

### ðŸ”¹ Method Calls

- Syntax: `methodName(arguments)`
- Methods are **expressions**, so they can be part of larger expressions.
- Arguments are **evaluated first** and passed as values.

Example:  
`Math.exp(-x*x/2) / Math.sqrt(2*Math.PI)`

---

### ðŸ”¹ Properties of Static Methods

- **Multiple arguments:** A method can accept more than one argument.
- **Multiple methods:** You can define many static methods in one file.
- **Overloading:** Methods with the same name but different signatures.
- **Multiple return statements:** You can return from several points.
- **Single return value:** Only one value returned per method.
- **Scope:** Variables declared inside a method are local to it.
- **Side effects:**
  - **Pure functions** â†’ always return the same result (e.g., `harmonic()`).
  - **Void methods** â†’ produce side effects but return no value.

---

### ðŸ”¹ Implementing Mathematical Functions

#### Gaussian Distribution

- **PDF:**  
  Ï•(x) = (1 / âˆš(2Ï€)) \* e^(-xÂ²/2)
- **CDF:**  
  Î¦(z) = âˆ«â‚‹âˆžá¶» Ï•(x) dx

- **Closed form:** Exists for Ï•(x), computed via Math functions.
- **No closed form:** Î¦(z) computed via approximation (Taylor series).
- Implemented in `Gaussian.java`.

---

### ðŸ”¹ Organizing Code with Static Methods

**Coupon.java** example separates tasks clearly:

1. Generate a random coupon value.
2. Perform the coupon collection experiment.
3. Compute and print the result.

Good programming practice: **separate tasks** into methods.

---

### ðŸ”¹ Argument Passing & Return Values

- **Pass by value:** Arguments are evaluated and copied to parameter variables.
- **Arrays as arguments:** Methods can receive arrays and modify them (side effects).
- **Arrays as return values:** Methods can return arrays.

Examples: `ArrayFunctionExamples.java`

---

### ðŸ”¹ Superposition of Sound Waves

To simulate harmonics or chords, combine multiple sound waves via **superposition** (adding waves and rescaling).  
`PlayThatTuneDeluxe.java` extends `PlayThatTune.java` to include harmonics.

---

## 2.2 Libraries and Clients

### ðŸ”¹ Overview

A **library** is a collection of static methods intended for reuse.  
A **client** is any program that uses those methods.

Example:  
`SAT.java` calls `cdf()` from `Gaussian.java`, which calls `pdf()`, which uses `Math` methods.

---

### ðŸ”¹ Key Concepts

- **public keyword:** Makes a method accessible to other programs.
- **Each module = one class** â†’ one `.java` file per class.
- **.class file:** Generated bytecode when compiled.
- **Automatic recompilation:** Java recompiles dependencies if modified.
- **Multiple `main()` methods:** Each class with `main()` can run independently.

---

### ðŸ”¹ API and Implementation

- **API:** Describes what a method does (the contract).
- **Implementation:** The Java code that fulfills that contract.

Example:  
`Gaussian.java` implements a **Gaussian API**.

---

### ðŸ”¹ Example Libraries

- **StdRandom.java** â†’ random numbers (various distributions)
- **StdArrayIO.java** â†’ input/output for arrays
- **StdStats.java** â†’ basic statistics and visualization
- **Sierpinski.java** & **IFS.java** â†’ iterated function systems (fractal generation)

---

### ðŸ”¹ Exercises

1. Extend `Gaussian.java` â†’ add `pdf(x, mu, sigma)` and `cdf(z, mu, sigma)` methods.
2. Create `Hyperbolic.java` â†’ implement sinh, cosh, tanh, coth, sech, csch.
3. Add `shuffle()` to `StdRandom.java` â†’ randomize arrays.
4. Implement full `StdArrayIO.java`.
5. Write `Matrix.java` and its client `MarkovSquaring.java`.

---

## 2.3 Recursion

### ðŸ”¹ Definition

A **recursive method** is a function that calls itself.  
Two key components:

1. **Base case:** Stops recursion.
2. **Reduction step:** Brings problem closer to the base case.

Example â€“ **Factorial**:

```java
public static long factorial(int n) {
    if (n == 1) return 1;
    return n * factorial(n - 1);
}
```

---

### ðŸ”¹ Examples of Recursion

- **Euclidâ€™s Algorithm (GCD):**

```java
public static int gcd(int p, int q) {
    if (q == 0) return p;
    return gcd(q, p % q);
}
```

- **Towers of Hanoi:** Recursive disk-moving puzzle.
- **Gray Code:** Generates binary sequences differing by one bit.
- **H-Tree:** Recursive fractal drawing.
- **Brownian Bridge:** Recursive random motion simulation.

---

### ðŸ”¹ Common Pitfalls

- **Missing base case:** Infinite recursion â†’ `StackOverflowError`.
- **No convergence:** Recursive call never reaches base case.
- **Excessive memory:** Too many recursive calls.
- **Excessive recomputation:** Inefficient recursion (e.g., naive Fibonacci).

---

### ðŸ”¹ Dynamic Programming

Efficient recursion via **memoization** or **tabulation**.

- **Top-down DP:** Store subproblem results (e.g., `TopDownFibonacci.java`).
- **Bottom-up DP:** Solve from smallest subproblems upward.

Example:

```java
public static long fibonacci(int n) {
    long[] f = new long[n + 1];
    f[0] = 0; f[1] = 1;
    for (int i = 2; i <= n; i++)
        f[i] = f[i - 1] + f[i - 2];
    return f[n];
}
```

---

### ðŸ”¹ Longest Common Subsequence (LCS)

Problem: Find the longest subsequence common to two strings.

Recursive formulation:

```
opt[i][j] = 0                              if i = m or j = n
          = opt[i+1][j+1] + 1              if s[i] = t[j]
          = max(opt[i][j+1], opt[i+1][j])  otherwise
```

**Goal:** Recover both the length and the subsequence by backtracking.

---

### ðŸ”¹ Modular Programming Benefits

- Extend language via libraries of static methods.
- Divide large programs into small, logical modules.
- Enable independent development, testing, and reuse.

---

**End of Chapter 2 Notes**
